import { NextRequest, NextResponse } from "next/server"
import { readFile } from "fs/promises"
import { join } from "path"
import { existsSync } from "fs"

/**
 * Route handler to serve individual registry item JSON files
 * Matches: /r/[name].json
 * 
 * This allows the shadcn CLI to fetch individual components:
 * npx shadcn@latest add http://localhost:3000/r/button.json
 * 
 * Note: In production, Next.js will serve static files from public/r/ automatically.
 * This route handler provides a fallback if files don't exist in public/r/.
 */
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ name: string }> }
) {
  try {
    const { name } = await params
    
    // Remove .json extension if present
    const componentName = name.replace(/\.json$/, "")
    
    // In production, try multiple paths where files might be located
    const possiblePaths = [
      // Development: project root
      join(process.cwd(), "public", "r", `${componentName}.json`),
      // Production: might be in different location
      join(process.cwd(), ".next", "server", "app", "public", "r", `${componentName}.json`),
      // Alternative production path
      join(process.cwd(), "public", "r", `${componentName}.json`),
    ]
    
    // Try to load from public/r directory (generated by shadcn build)
    for (const publicPath of possiblePaths) {
      if (existsSync(publicPath)) {
        const content = await readFile(publicPath, "utf-8")
        return NextResponse.json(JSON.parse(content), {
          headers: {
            "Content-Type": "application/json",
            "Cache-Control": "public, max-age=3600, s-maxage=3600",
          },
        })
      }
    }
    
    // Fallback: generate on-the-fly from registry.json
    const registryPaths = [
      join(process.cwd(), "registry.json"),
      join(process.cwd(), ".next", "server", "registry.json"),
    ]
    
    for (const registryPath of registryPaths) {
      if (existsSync(registryPath)) {
        const registryContent = await readFile(registryPath, "utf-8")
        const registry = JSON.parse(registryContent)
        
        const item = registry.items?.find(
          (item: { name: string }) => item.name === componentName
        )
        
        if (item) {
          return NextResponse.json(item, {
            headers: {
              "Content-Type": "application/json",
              "Cache-Control": "public, max-age=3600, s-maxage=3600",
            },
          })
        }
      }
    }
    
    return NextResponse.json(
      { error: `Registry item "${componentName}" not found` },
      { status: 404 }
    )
  } catch (error) {
    console.error("Error serving registry item:", error)
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    )
  }
}
